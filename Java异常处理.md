###     Java的异常体系

![image-20191030082626565](D:\sgmuserprofile\sqgdua\AppData\Roaming\Typora\typora-user-images\image-20191030082626565.png)

### 异常捕捉流程

![image-20191030082701312](D:\sgmuserprofile\sqgdua\AppData\Roaming\Typora\typora-user-images\image-20191030082701312.png)

#### 使用try...catch捕获异常

* 执行try块里的业务逻辑代码时出现异常，系统自动生成一个异常对象，该异常对象被提交给Java运行时环境，这个过程被称为抛出（throw）异常。
* Java运行时环境收到异常对象时，会寻找能处理该异常对象的块，如果找到合适的块并把该异常对象交给该块处理，那这个过程被称为捕获（）异常；如果运行时环境找不到捕获异常的块，则运行时环境终止，程序也将退出

#### 使用finally回收资源

* 程序在try块里打开了一些物理资源（例如数据库连接、网络连接和磁盘文件等），这些物理资源都必须显式回收。 
* 为了保证一定能回收try块中打开的物理资源，异常处理机制提供了finally块。不管try块中的代码是否出现异常，也不管哪一个catch块被执行，finally块总会被执行。 

#### Java9的自动关闭资源的try语句



~~~java
try( 
   // 此处声明的资源， 系统可以自动关闭它。
)
{
    // 捕获异常
}
~~~



自动关闭资源的try语句， 可以没有catch和finally——try块可以孤独地存在。

•Java 9允许在圆括号之外声明、创建资源，只要在圆括号里列出需要自动关闭的资源即可，多个资源之间用英文逗号隔开。

•自动关闭资源的try语句，有两个注意点：

–只有放在try后面的圆括号里的资源才会被关闭。

–能被自动关闭的资源必须实现Closeable或AutoCloseable接口。

#### 访问异常信息

* 如果程序需要在catch块中访问异常对象的相关信息，可以通过调用catch后异常形参的方法来获得。当Java运行时决定调用某个catch块来处理该异常对象时，会将该异常对象赋给catch块后的异常参数，程序就可以通过该参数来获得该异常的相关信息。
* 所有异常对象都包含了如下几个常用方法：
  * ***getMessage()***：返回该异常的详细描述字符串。
  * ***printStackTrace()***：将该异常的跟踪栈信息输出到标准错误输出。
  * ***printStackTrace(PrintStream s)***：将该异常的跟踪栈信息输出到指定输出流。
  * ***getStackTrace()***：返回该异常的跟踪栈信息。 

#### 异常处理

~~~java
try
{
	需要检测的代码；
}
catch(异常类  变量)
{
	异常处理代码；
}
finally
{
	一定会执行的代码；	
}
/*
***Finally代码块只有一种情况不会被执行。就是在之前执行了System.exit(0)。
*/

~~~

### 多异常捕捉

* 在Java 7以前，每个catch块只能捕捉一个异常。从Java 7开始，一个catch块可以捕捉多个异常。

  ~~~java
  catch(异常1 | 异常 2 | 异常3 ex)
  {
      
  }
  ~~~

  

> 多个异常之间用竖线隔开。

> 多异常捕捉时，异常变量之前有隐式final修饰。

### 异常嵌套

* 异常处理流程代码可以放在任何能放可执行性代码的地方，因此完整的异常处理流程既可放在try块里，也可放在catch块里，也可放在finally块里。
* 异常处理嵌套的深度没有很明确的限制，但通常没有必要使用超过两层的嵌套异常处理，层次太深的嵌套异常处理没有太大不要，而且导致程序可读性降低。 

### Checked异常与Running异常

​        Java的异常被分为两大类：Checked异常和Runtime异常（运行时异常）。所有RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常  

#### Checked异常的处理

* 当前方法明确知道如何处理该异常，程序应该使用try...catch块来捕获该异常，然后在对应的catch块中修改该异常。例如前面介绍的五子棋游戏中处理用户输入不合法的异常，程序在catch块中打印对用户的提示信息，重新开始下一次循环。
* 当前方法不知道如何处理这种异常，应该在定义该方法时声明抛出该异常。

#### Running异常的处理

* Runtime异常则更加灵活，Runtime异常无需显式声明抛出。
* 如果程序需要捕捉Runtime异常，也可以使用try...catch块来捕捉Runtime异常。

### 抛出异常

#### 使用throws声明抛出异常

* throws声明抛出异常的思路是：当前方法不知道应该如何这种类型的异常，该异常应该由上一级调用者处理，如果main方法也不知道应该如何处理这种类型的异常，也可以使用throws声明抛出异常，该异常将交给JVM处理。JVM对异常的处理方法是：打印异常跟踪栈信息，并中止程序运行，这就是前面程序在遇到异常后自动结束的原因。
* throws声明抛出只能在方法签名中使用，***throws可以声明抛出多个异常类，多个异常类之间以逗号隔开。***throws声明抛出的语法格式如下

​              ` throws ExceptionClass1 , ExceptionClass2...`



#### 使用throw抛出异常

* 如果需要在程序中自行抛出异常，应使用throw语句，throw语句可以单独使用，***throw语句抛出的不是异常类，而是一个异常实例，而且每次只能抛出一个异常实例。***throw语句的语法格式如下：

  ​						`throw ExceptionInstance;`

* 如果throw语句抛出的异常是Checked异常，则该throw语句要么处于try块里，显式捕获该异常，要么放在一个带throws声明抛出的方法中，即把该异常交给该方法的调用者处理。



#### Java7增强的throw语句

~~~java
try

{

    new FileInputStream(“a.txt”);

}

Catch(Exception ex)

{

   ex.printStackTrace();

    throw ex;   //①

}
~~~



> 从JDK 7开始，Java编译器可以只能地识别①号代码处抛出的异常只是FileNotFoundException异常。

### 自定义异常类

* 程序很少会自行抛出系统异常，因为异常的类名通常包含了该异常的有用信息。所以在选择抛出什么异常时，应该选择合适的异常类，从而可以明确地描述该异常情况。在这种情形下，应用程序常常需要抛出自定义异常。

* 用户自定义异常都应该继承Exception基类，如果希望自定义Runtime异常，则应该继承RuntimeException基类。定义异常类时通常需要提供两种构造器：一个是无参数的构造器；另一个是带一个字符串参数的构造器，这个字符串将作为该异常对象的详细说明（也就是异常对象的getMessage方法的返回值）。

### 异常链

* 当业务逻辑层访问持久层出现SQLException异常时，程序不应该把底层的SQLException异常传到用户界面，原因有如下两个：
  * 对于正常用户而言，他们不想看到底层SQLException，SQLException对他们使用该系统没有任何帮助。
  * 对于恶意用户而言，将SQLException暴露出来是一种不安全的。

### Java的异常跟踪栈

* 异常对象的printStackTrace方法用于打印异常的跟踪栈信息，根据printStackTrace方法的输出结果，我们可以找到异常的源头，并跟踪到异常一路触发的过程。
* 面向对象的应用程序运行时，经常会发生一系列方法调用，从而形成“方法调用栈”，异常的传播则与相反：只要异常没有被完全捕获（包括异常没有被捕获，或异常被处理后重新抛出了新异常），异常从发生异常的方法逐渐向外传播，首先传给该方法的调用者，该方法调用者再次创给其调用者……直至最后传到 main方法，如果main方法依然没有处理该异常，JVM会中止该程序，并打印异常的跟踪栈信息。

### 异常处理规则

1. 不要过度使用异常
2. 不要使用过于庞大的try块
3. 避免使用Catch All语句 
4. 不要忽略捕获到异常  

